<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ç‚¹äº‘å®æ—¶æ˜¾ç¤º</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: #1a1a2e;
      color: #fff;
      overflow: hidden;
    }
    #container { width: 100vw; height: 100vh; }
    #info {
      position: absolute;
      top: 10px;
      left: 10px;
      background: rgba(0,0,0,0.8);
      padding: 15px 20px;
      border-radius: 8px;
      font-size: 14px;
      z-index: 100;
      min-width: 220px;
      border: 1px solid #333;
    }
    #info h3 { margin-bottom: 12px; color: #4fc3f7; font-size: 16px; }
    #info .stat { margin: 8px 0; display: flex; justify-content: space-between; }
    #info .label { color: #888; }
    #info .value { color: #4fc3f7; font-weight: bold; }
    #status {
      position: absolute;
      top: 10px;
      right: 10px;
      padding: 8px 16px;
      border-radius: 20px;
      font-size: 12px;
      font-weight: bold;
      z-index: 100;
    }
    #status.connected { background: #4caf50; color: #fff; }
    #status.disconnected { background: #f44336; color: #fff; }
    #status.connecting { background: #ff9800; color: #fff; }
    #controls {
      position: absolute;
      bottom: 20px;
      left: 20px;
      background: rgba(0,0,0,0.8);
      padding: 15px;
      border-radius: 8px;
      z-index: 100;
      border: 1px solid #333;
    }
    #controls button {
      padding: 10px 20px;
      margin: 0 5px;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-size: 14px;
      font-weight: 500;
      transition: all 0.2s;
    }
    #controls button.primary { background: #4fc3f7; color: #000; }
    #controls button.danger { background: #f44336; color: #fff; }
    #controls button:hover { transform: scale(1.05); opacity: 0.9; }
    #controls button:disabled { opacity: 0.5; cursor: not-allowed; transform: none; }
    #hint {
      position: absolute;
      bottom: 20px;
      right: 20px;
      background: rgba(0,0,0,0.8);
      padding: 12px 16px;
      border-radius: 8px;
      font-size: 12px;
      color: #888;
      z-index: 100;
      border: 1px solid #333;
    }
    #hint p { margin: 4px 0; }
    #loading {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      text-align: center;
      z-index: 200;
    }
    #loading.hidden { display: none; }
    .spinner {
      width: 50px;
      height: 50px;
      border: 4px solid #333;
      border-top-color: #4fc3f7;
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin: 0 auto 15px;
    }
    @keyframes spin { to { transform: rotate(360deg); } }
  </style>
</head>
<body>
  <div id="container"></div>

  <div id="loading">
    <div class="spinner"></div>
    <div>æ­£åœ¨åŠ è½½3Dåœºæ™¯...</div>
  </div>

  <div id="info">
    <h3>ğŸ“¡ ç‚¹äº‘å®æ—¶æ˜¾ç¤º</h3>
    <div class="stat"><span class="label">æ€»ç‚¹æ•°</span><span class="value" id="totalPoints">0</span></div>
    <div class="stat"><span class="label">ç´¯è®¡å¸§æ•°</span><span class="value" id="frameCount">0</span></div>
    <div class="stat"><span class="label">æ¸²æŸ“FPS</span><span class="value" id="fps">0</span></div>
    <div class="stat"><span class="label">æ— äººæœºä½ç½®</span><span class="value" id="dronePos">ç­‰å¾…æ•°æ®...</span></div>
  </div>

  <div id="status" class="connecting">è¿æ¥ä¸­...</div>

  <div id="controls">
    <button class="primary" id="pauseBtn">â¸ æš‚åœ</button>
    <button class="danger" id="clearBtn">ğŸ—‘ æ¸…ç©º</button>
  </div>

  <div id="hint">
    <p>ğŸ–± å·¦é”®æ‹–æ‹½æ—‹è½¬è§†è§’</p>
    <p>ğŸ–± å³é”®æ‹–æ‹½å¹³ç§»</p>
    <p>ğŸ–± æ»šè½®ç¼©æ”¾</p>
  </div>

  <!-- Three.js (ä½¿ç”¨å›½å†…CDN) -->
  <script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>
  <script src="https://unpkg.com/three@0.160.0/examples/js/controls/OrbitControls.js"></script>

  <script>
    // é…ç½®
    const WS_URL = `ws://${window.location.hostname}:${window.location.port || 3001}`;
    const MAX_POINTS = 500000;

    // çŠ¶æ€
    let ws = null;
    let isPaused = false;
    let totalPoints = 0;
    let frameCount = 0;
    let lastFpsTime = Date.now();
    let fpsFrameCount = 0;

    // Three.js åœºæ™¯
    let scene, camera, renderer, controls;
    let pointCloud, pointGeometry;
    let droneModel;
    let positions = [];
    let colors = [];

    // åˆå§‹åŒ– Three.js
    function initThree() {
      try {
        // åœºæ™¯
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x1a1a2e);

        // ç›¸æœº
        camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(8, 8, 8);
        camera.up.set(0, 0, 1);

        // æ¸²æŸ“å™¨
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.getElementById('container').appendChild(renderer.domElement);

        // æ§åˆ¶å™¨
        controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.target.set(0, 0, 0);

        // ç¯å…‰
        scene.add(new THREE.AmbientLight(0xffffff, 0.6));
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
        dirLight.position.set(10, 10, 10);
        scene.add(dirLight);

        // ç½‘æ ¼ (XYå¹³é¢)
        const gridHelper = new THREE.GridHelper(20, 20, 0x4fc3f7, 0x333333);
        gridHelper.rotation.x = Math.PI / 2;
        scene.add(gridHelper);

        // åæ ‡è½´
        const axesHelper = new THREE.AxesHelper(3);
        scene.add(axesHelper);

        // æ·»åŠ åæ ‡è½´æ ‡ç­¾æç¤º
        addAxisLabels();

        // ç‚¹äº‘å‡ ä½•ä½“
        pointGeometry = new THREE.BufferGeometry();
        const material = new THREE.PointsMaterial({
          size: 0.03,
          vertexColors: true,
          sizeAttenuation: true
        });
        pointCloud = new THREE.Points(pointGeometry, material);
        scene.add(pointCloud);

        // æ— äººæœºæ¨¡å‹
        createDroneModel();

        // çª—å£è°ƒæ•´
        window.addEventListener('resize', onWindowResize);

        // éšè—åŠ è½½æç¤º
        document.getElementById('loading').classList.add('hidden');

        // æ¸²æŸ“å¾ªç¯
        animate();

        console.log('âœ… 3Dåœºæ™¯åˆå§‹åŒ–æˆåŠŸ');
      } catch (error) {
        console.error('âŒ 3Dåœºæ™¯åˆå§‹åŒ–å¤±è´¥:', error);
        document.getElementById('loading').innerHTML = '<div style="color: #f44336;">3Dåœºæ™¯åŠ è½½å¤±è´¥<br>è¯·åˆ·æ–°é¡µé¢é‡è¯•</div>';
      }
    }

    function addAxisLabels() {
      // åˆ›å»ºç®€å•çš„åæ ‡è½´æŒ‡ç¤º
      const createLabel = (text, position, color) => {
        const canvas = document.createElement('canvas');
        canvas.width = 64;
        canvas.height = 64;
        const ctx = canvas.getContext('2d');
        ctx.fillStyle = color;
        ctx.font = 'bold 48px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(text, 32, 32);

        const texture = new THREE.CanvasTexture(canvas);
        const material = new THREE.SpriteMaterial({ map: texture });
        const sprite = new THREE.Sprite(material);
        sprite.position.copy(position);
        sprite.scale.set(0.5, 0.5, 0.5);
        scene.add(sprite);
      };

      createLabel('X', new THREE.Vector3(3.5, 0, 0), '#ff4444');
      createLabel('Y', new THREE.Vector3(0, 3.5, 0), '#44ff44');
      createLabel('Z', new THREE.Vector3(0, 0, 3.5), '#4444ff');
    }

    function createDroneModel() {
      droneModel = new THREE.Group();

      // ä¸»ä½“
      const bodyGeom = new THREE.BoxGeometry(0.3, 0.3, 0.08);
      const bodyMat = new THREE.MeshStandardMaterial({ color: 0x4fc3f7, metalness: 0.8, roughness: 0.2 });
      droneModel.add(new THREE.Mesh(bodyGeom, bodyMat));

      // å‰æ–¹æŒ‡ç¤ºå™¨ (çº¢è‰²é”¥ä½“æŒ‡å‘Xæ­£æ–¹å‘)
      const coneGeom = new THREE.ConeGeometry(0.04, 0.12, 4);
      const coneMat = new THREE.MeshStandardMaterial({ color: 0xff4d4f, emissive: 0xff4d4f, emissiveIntensity: 0.5 });
      const cone = new THREE.Mesh(coneGeom, coneMat);
      cone.position.set(0.2, 0, 0);
      cone.rotation.z = -Math.PI / 2;
      droneModel.add(cone);

      // èºæ—‹æ¡¨
      const propGeom = new THREE.CylinderGeometry(0.08, 0.08, 0.01, 32);
      const propMat = new THREE.MeshStandardMaterial({ color: 0x52c41a, transparent: true, opacity: 0.6 });
      [[-0.12, -0.12], [0.12, -0.12], [-0.12, 0.12], [0.12, 0.12]].forEach(([x, y]) => {
        const prop = new THREE.Mesh(propGeom, propMat);
        prop.position.set(x, y, 0.05);
        droneModel.add(prop);
      });

      // åˆå§‹ä½ç½®åœ¨åŸç‚¹
      droneModel.position.set(0, 0, 0);
      scene.add(droneModel);
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function animate() {
      requestAnimationFrame(animate);
      controls.update();
      renderer.render(scene, camera);

      // è®¡ç®—FPS
      fpsFrameCount++;
      const now = Date.now();
      if (now - lastFpsTime >= 1000) {
        document.getElementById('fps').textContent = fpsFrameCount;
        fpsFrameCount = 0;
        lastFpsTime = now;
      }
    }

    // WebSocket è¿æ¥
    function connectWebSocket() {
      console.log('ğŸ”— è¿æ¥ WebSocket:', WS_URL);
      document.getElementById('status').className = 'connecting';
      document.getElementById('status').textContent = 'è¿æ¥ä¸­...';

      try {
        ws = new WebSocket(WS_URL);

        ws.onopen = () => {
          document.getElementById('status').className = 'connected';
          document.getElementById('status').textContent = 'å·²è¿æ¥';
          console.log('âœ… WebSocket å·²è¿æ¥');
        };

        ws.onclose = () => {
          document.getElementById('status').className = 'disconnected';
          document.getElementById('status').textContent = 'å·²æ–­å¼€';
          console.log('âŒ WebSocket å·²æ–­å¼€ï¼Œ5ç§’åé‡è¿...');
          setTimeout(connectWebSocket, 5000);
        };

        ws.onerror = (err) => {
          console.error('âŒ WebSocket é”™è¯¯:', err);
          document.getElementById('status').className = 'disconnected';
          document.getElementById('status').textContent = 'è¿æ¥é”™è¯¯';
        };

        ws.onmessage = (event) => {
          try {
            const msg = JSON.parse(event.data);
            handleMessage(msg);
          } catch (e) {
            console.error('æ¶ˆæ¯è§£æé”™è¯¯:', e);
          }
        };
      } catch (error) {
        console.error('âŒ WebSocket åˆ›å»ºå¤±è´¥:', error);
        document.getElementById('status').className = 'disconnected';
        document.getElementById('status').textContent = 'è¿æ¥å¤±è´¥';
        setTimeout(connectWebSocket, 5000);
      }
    }

    function handleMessage(msg) {
      if (msg.type === 'mqtt_message') {
        const { topic, data } = msg;

        // ç‚¹äº‘æ•°æ®
        if ((topic === '/daf/pointcloud' || topic === '/daf/pointcloud_rgb') && !isPaused) {
          if (data.points && data.points.length > 0) {
            addPoints(data.points);
            frameCount++;
            document.getElementById('frameCount').textContent = frameCount;
          }
        }

        // ä½å§¿æ•°æ®
        if (topic === '/daf/local/odometry') {
          updateDronePosition(data);
        }
      }
    }

    function addPoints(newPoints) {
      // æ£€æŸ¥æ˜¯å¦è¶…è¿‡æœ€å¤§ç‚¹æ•°
      if (totalPoints >= MAX_POINTS) return;

      const availableSpace = MAX_POINTS - totalPoints;
      const pointsToAdd = newPoints.slice(0, availableSpace);

      pointsToAdd.forEach(point => {
        const x = point.xyz?.x ?? 0;
        const y = point.xyz?.y ?? 0;
        const z = point.xyz?.z ?? 0;
        const intensity = (point.intensity ?? 128) / 255;

        positions.push(x, y, z);
        // é¢œè‰²ï¼šè“è‰²åˆ°çº¢è‰²æ¸å˜
        colors.push(intensity, 0.3, 1 - intensity);
      });

      totalPoints += pointsToAdd.length;
      document.getElementById('totalPoints').textContent = totalPoints.toLocaleString();

      // æ›´æ–°å‡ ä½•ä½“
      pointGeometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
      pointGeometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
      pointGeometry.computeBoundingSphere();
    }

    function updateDronePosition(data) {
      const pos = data.pose?.position || data.position;
      const ori = data.pose?.orientation || data.orientation;

      if (pos && droneModel) {
        droneModel.position.set(pos.x, pos.y, pos.z);
        document.getElementById('dronePos').textContent =
          `(${pos.x.toFixed(2)}, ${pos.y.toFixed(2)}, ${pos.z.toFixed(2)})`;
      }

      if (ori && droneModel) {
        const quat = new THREE.Quaternion(ori.x, ori.y, ori.z, ori.w);
        droneModel.setRotationFromQuaternion(quat);
      }
    }

    function clearPoints() {
      positions = [];
      colors = [];
      totalPoints = 0;
      frameCount = 0;
      pointGeometry.setAttribute('position', new THREE.Float32BufferAttribute([], 3));
      pointGeometry.setAttribute('color', new THREE.Float32BufferAttribute([], 3));
      document.getElementById('totalPoints').textContent = '0';
      document.getElementById('frameCount').textContent = '0';
      console.log('ğŸ—‘ ç‚¹äº‘å·²æ¸…ç©º');
    }

    // äº‹ä»¶ç»‘å®š
    document.getElementById('pauseBtn').addEventListener('click', function() {
      isPaused = !isPaused;
      this.textContent = isPaused ? 'â–¶ ç»§ç»­' : 'â¸ æš‚åœ';
      this.className = isPaused ? 'danger' : 'primary';
      console.log(isPaused ? 'â¸ å·²æš‚åœ' : 'â–¶ å·²ç»§ç»­');
    });

    document.getElementById('clearBtn').addEventListener('click', clearPoints);

    // åˆå§‹åŒ–
    window.onload = function() {
      initThree();
      connectWebSocket();
    };
  </script>
</body>
</html>
